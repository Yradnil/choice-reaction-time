{{ block title }} SART MT {{ endblock }} {{ block content }} {% load otree
static %}
<link rel="stylesheet" href="{% static 'global/style1.css' %}" />

<body>
  <div class="circle-container">
    <div class="circle-button" id="center-circle">3</div>
    <div class="circle-button" id="hold-button"></div>
  </div>

  <script>
    const centerCircle = document.getElementById("center-circle");
    const holdButton = document.getElementById("hold-button");

    const colors = ["#FFCC00", "#90D050", "#3C5DAE", "#7A8DBE", "#005000"]; // last = green
    let currentColor = "";
    let isGreen = false;
    let showingFeedback = false;
    let intervalId = null;
    let trialIndex = 0;
    let cycleStarted = false;
    let rtStartTime = 0;
    let lastClick = performance.now();
    let colorCycleInterval = null;
    let awaitingResponse = false;
    let missTimeout = null;
    let timeoutId = null;
    let holding = false;
    let mt = 0;

    function startTrial() {
      cycleStarted = true;
      isGreen = false;
      centerCircle.style.backgroundColor = "gray";
      centerCircle.innerText = "";
      setTimeout(() => {
        startColorCycle();
      }, 2000); // Initial gray delay
    }

    function startColorCycle() {
      showNextStimulus();
    }

    function showNextStimulus() {
      if (showingFeedback || !cycleStarted) return;

      clearTimeout(missTimeout);

      const colorIndex = Math.floor(Math.random() * colors.length);
      currentColor = colors[colorIndex];
      isGreen = currentColor === "#005000";

      centerCircle.style.backgroundColor = currentColor;
      centerCircle.innerText = "3";

      stimulusShownAt = isGreen ? performance.now() : null;
      awaitingResponse = isGreen;

      if (isGreen) {
        rtStartTime = performance.now();
        missTimeout = setTimeout(() => {
          if (awaitingResponse) {
            awaitingResponse = false;
            showMessage("Missed!");
          }
        }, 2000);
      }

      // Instead of setInterval, chain next call manually:
      timeoutId = setTimeout(() => {
        if (!showingFeedback ) {
          startTrial();
        }
      }, 2000);
    }

    function showMessage(message) {
      showingFeedback = true;
      clearInterval(colorCycleInterval);
      clearTimeout(missTimeout);

      centerCircle.innerText = message;

      setTimeout(() => {
        showingFeedback = false;
        cycleStarted = false;
        resetTrial();
        if (holding) {
          startTrial();
        }
      }, 1000); // 1s feedback duration
    }

    function resetTrial() {
      isGreen = false;
      centerCircle.style.backgroundColor = "gray";
      centerCircle.innerText = "";
    }

    function handleResponse() {
      mt = performance.now() - lastClick;
      if (showingFeedback || !cycleStarted) return;
      cycleStarted = false;
      if (isGreen) {
        showMessage("Correct!");
        liveSend({ movement_time: mt, trial_index: trialIndex });
        trialIndex++;
      }
    }

    centerCircle.addEventListener("click", handleResponse);

    holdButton.addEventListener("mousedown", () => {
      if (cycleStarted || holding) return;

      holding = true;
      holdButton.style.backgroundColor = "gray";
      startTrial();
    });

    holdButton.addEventListener("mouseup", () => {
      lastClick = performance.now();
      const rtLeave = performance.now() - rtStartTime;
      holding = false;
      clearTimeout(timeoutId);
      liveSend({ leave_time: rtLeave, trial_index: trialIndex });
      if (!isGreen) {
        showMessage("Too early!");
        cycleStarted = false;
      }
      holdButton.style.backgroundColor = "white";
    });

    holdButton.addEventListener("mouseleave", () => {
      if (holding) {
        holding = false;
        
        clearTimeout(timeoutId);
        holdButton.style.backgroundColor = "white";
        showMessage("Release your mouse");
      }
    });
  </script>
</body>

{{ formfields }} {{ next_button }} {{ endblock }}
